#include "pch.h" //Основные библиотеки
#include <iostream> //cin cout

using namespace std;//Пространство имен

struct Stek {//Описываем нашу структуру 
	int info;//Создаем поле для хранения числа
	Stek *next;//Указатель на следующий элемент
}*head = nullptr;//Сразу объявляем глобальный указатель на вершину нашего стека

//Функция для добавления элемента в Стек
void push(int in) //Передаем данные которые надо положить в элемент стека
{
	Stek *bufer = new Stek;//Выделяем память для нового элемента. bufer указывает на место в памяти где этот элемент находится. 

	bufer->next = head; //Устанавливаем связь. Теперь наш новый элемент указывает на бывшую вершину.

	bufer->info = in;//Заполняем поля нашего нового элемента.

	head = bufer;//Устанавливаем новую вершину стека.
}
//////////////////////////////////////////////////////////////////////////////////////////////

void View()//Функция для Просмотра стека
{
	if (head == nullptr)
	{
		cout << "Стек пуст";
		return;//Выход
	}

	Stek *t = head;//переменная для хранения нашего местоположения в стеке

	while (t != nullptr)//Пока элемент на что то указывает , идем по нему 
	{
		cout << t->info << " ";//Вывод значения элемента в котором сейчас находимся 
		t = t->next;//Переходим на новый элемент	
	}
}
//////////////////////////////////////////////////////////////////////////////////////////////

//Функция для удаления вершины стека
void pop()
{
	Stek *bufer = head;//Запоминаем элемент который будем удалять
	head = head->next;//Переносим  указатель вершины на след. элемент
	delete bufer;//Удаляем бывшую вершину
}
//////////////////////////////////////////////////////////////////////////////////////////////

//Функция для удаление элемента по его номеру
void del(int num)//В качестве аргумента принимаем номер элемента который будем удалять 
{
	if (head == nullptr)
	{
		cout << "Стек пуст";
		return;//Выход
	}

	if (num == 0)
	{
		pop();//Вызываем функцию для удаления вершины стека
		return;//Выход.Мы всё сделали
	}
	
		Stek *previous = head;//Запоминаем прошлый элемент

		if (previous->next == nullptr)//Если сработало данное условие значит в стеке только 1 элемент.И так как у нас только один элемент , а пользователь явно пожелал удалить элемент номер которого > 0 то смело можем сказать что пользователь хочет удалить элемент которого нет.
		{
			cout << "Элемента с таким номером не сущ.";
			return;//Выход
		}

		for (int i = 1; i < num ; i++)//Идем до нашего элемента не доходя на 1 элемент  
		{
			if (previous->next == nullptr)//Если мы не дошли до указоного номера , а стек уже закончился , значит такого элемента не сущ.
			{
				cout << "Элемента с таким номером не сущ.";
				return;//Выход
			}
			previous = previous->next;//Идем на след. элемент
		}

		Stek *ToDel = previous->next;//Элемент который будем удалять 

		previous->next = ToDel->next;//выбрасываем элемент из стека 

		delete ToDel;//Удаляем элемент

}
//////////////////////////////////////////////////////////////////////////////////////////////

//Функция для удаление всего стека
void delStek()
{
	if (head == nullptr)
	{
		cout << "Стек пуст";
		return;//Выход
	}

	while (head != nullptr)//Пока не дайдем до пустоты , удаляем вершину
	{
		pop();//Что происходит в этой функции можно посмотреть выше
	}
}
//////////////////////////////////////////////////////////////////////////////////////////////

int main()//Точка входа
{
	/*
	Применим данные функции для решения задачи

	Задание:
	Создать стек состоящий из 5 элементов. Удалить предпоследний элемент. И потом отчистить память от стека

	Разобьем задачу на подпункты:
	1)Создать стек состоящий из 5 чисел.
	2)Удалить предпоследний элемент.
	3)Очистить память от стека
	*/

	//Выполним первый пункт.Создадим Стек.Для этого у нас есть функция push()
	//Добавить 5 элементов в Стек можно просто вызвав функцию push() 5 раз

	//push(1);//Добавляем элемент в стек со значением 1
	//push(2);//Добавляем элемент в стек со значением 2
	//push(3);//Добавляем элемент в стек со значением 3
	//push(4);//Добавляем элемент в стек со значением 4
	//push(5);//Добавляем элемент в стек со значением 5

	//Но более простым и правильным  мне кажется способ с использованием цикла

	for (int i=0;i<5;i++)//Данный цикл добавит 5 элементов в стек
	{
		push(i);
	}

	//Стек создан.Давайте теперь удалим предпоследний элемент!Вот только как понять где у нас предпоследний элемент?
	//Вообще в данной задаче у нас сказано что в стеке 5 элементов и поэтому мы можем написать 1 строчку del(3) и курить бамбук , но давайте вспомним что экзамен наш у Кукина , а поэтому он полюбому на такое скажет что-то вроде "А напиши решение данной задачи для случая,когда размер стека не известен".
	//Я вижу 2 способа решения такой задачи.

	//1)Узнаем номер нашего предпоследнего элемента , а после его удаляем при помощи del().
	//как узнать номер предпоследнего элемента? Да очень просто ! Возьмем код из функции View() и немного модифицируем под наши нужды

	/*
	int pos = 0;

	Stek *t = head;//переменная для хранения нашего местоположения в стеке

	while (t->next->next != nullptr)//Идем до пред. последнего элемента
	{
		pos++;//Увеличиваем счетчик
		t = t->next;//Переходим на новый элемент	
	}

	del(pos);
	*/
	//Готово!

	//2)Идем по стеку и останавливаемся перед пред. последним.
	//как до него дойти? Код из View() в помощь!

	Stek *t = head;//переменная для хранения нашего местоположения в стеке

	while (t->next->next->next != nullptr)//Идем до пред. пред. последнего элемента
	{
		t = t->next;//Переходим на новый элемент	
	}

	//А тут уже похожа логика на del()
	Stek *ToDel = t->next;//Элемент который будем удалять 

	t->next = ToDel->next;//выбрасываем элемент из стека 

	delete ToDel;//Удаляем элемент
	//Готово!

	//Тут можно ещё несколько способов придумать для решения.Выбирайте тот способ который вам наиболее понятен.Все они дают один и тот же результат.

	//Ну остался последний пункт.Освобождение памяти!
	//Ну тут уже детский сад если есть нужные функции
	delStek();
	//Готово!
}
